import threading
import time 
import heapq

class Task :
   def __init__(self, name , func, priority = 1 ):
      self.name = name 
      self.func= func
      self.status = "pending"
      self.priority = priority 
      self.submitted_at = time.strftime("%H:%M:%S")
      self.completed_at = None 
   def __lt__(self, other):
      return self.priority < other.priority

   def run(self):
      self.status= "Running"
      print (f"Running task : {self.name} ; priority :{self.priority}")
      try:
        self.func()
        self.status = "completed"
        self.completed_at = time.strftime("%H:%M:%S") 
      except Exception as e:
         self.status = "Failed"
         print (f"task {self.name} failed with{e}error")
        


class Taskqueue :
   def __init__(self):
      self.tasks = []
      self.lock = threading.Lock()
   

   def add_task(self, name , func, priority = 1):
      task  = Task(name , func, priority)
      with self.lock:
         heapq.heappush(self.tasks, task)
      print(f"Task'{name}' (Priority : {priority}) added ")

   def get_task(self):
         with self.lock:
             if self.tasks:
                 return heapq.heappop(self.tasks)
         return None

   def add_periodic_task(queue, name, func, interval, priority=1):
        periodic = PeriodicTask(queue, name, func, interval, priority)
        periodic.start()
        print(f"Started periodic task: {name} (every {interval}s)")             
            
         
   
   def show_task(self):
        with self.lock:
            if not self.tasks:
                print("No tasks in queue.")
                return
            for i, task in enumerate(self.tasks, start=1):
                print(f"{i}. {task.name} - {task.status} (submitted: {task.submitted_at})")
                
    
          


class Worker (threading.Thread):
   def __init__ (self , queue ):
      super().__init__()
      self.queue = queue
      self.daemon = True

   def run(self):
      while True :
         task = self.queue.get_task()
         if task:
            task.run()
         else :
            time.sleep(1)


class PeriodicTask(threading.Thread):
    def __init__(self, queue, name, func, interval, priority=5):
        super().__init__()
        self.queue = queue
        self.name = name
        self.func = func
        self.interval = interval
        self.priority = priority
        self.daemon = True

    def run(self):
        while True:
            self.queue.add_task(self.name, self.func, self.priority)
            time.sleep(self.interval)

    
    

      
def say_hello ():
      print ("hello world")

def write_log ():
      print ("Writing log Entry....")


# CLI
if __name__ == "__main__":
   queue = Taskqueue()

   workers = [Worker(queue) for _ in range(2)]
   for w in workers:
       w.start()



   while True :
      print ("\n ----Task Queue Menu----")
      print("1.Add Hello Task")
      print("2.Add Log Task")
      print("3. Add Peroidic Hello (5s)")
      print("4. Show all Task")
      print("5.Exit")

      choice = input ("enter Choice: ")

      if choice =="1":
         queue.add_task("Say Hello",say_hello, priority=2)
      elif choice == "2":
         queue.add_task("write log",write_log, priority=1)
      elif choice == "3":
         queue.add_periodic_task("Periodic Hello", say_hello, priority=1, interval=5)
      elif choice == "4":
         queue.show_task()
      elif choice == "5":
         print("Exiting.....")
         break 
      else :
         print ("Invalid choice!!")

         

   
    
      
      
